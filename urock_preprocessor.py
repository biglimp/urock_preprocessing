# -*- coding: utf-8 -*-
"""
/***************************************************************************
 URockPreprocessor
                                 A QGIS plugin
 This plugin prepares building and vegetation data for the URock wind model
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-09-02
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Fredrik Lindberg
        email                : fredrikl@gvc.gu.se
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QFileDialog, QMessageBox
from qgis.gui import QgsMapLayerComboBox, QgsFieldComboBox
from qgis.core import QgsMapLayerProxyModel, QgsFieldProxyModel, QgsVectorLayer, QgsApplication, QgsProperty

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .urock_preprocessor_dialog import URockPreprocessorDialog
import os.path
import webbrowser
import numpy as np
from osgeo import gdal
from osgeo.gdalconst import GDT_Float32

# importing native QGIS tools
from qgis.analysis import QgsNativeAlgorithms
QgsApplication.processingRegistry().addProvider(QgsNativeAlgorithms())
import processing
# from processing.core.Processing import Processing


class URockPreprocessor:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'URockPreprocessor_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&URock Preprocessor')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

        self.dlg = URockPreprocessorDialog()
        self.dlg.runButton.clicked.connect(self.start_progress)
        self.dlg.pushButtonSaveBuilding.clicked.connect(self.saveshapefileBuilding)
        self.dlg.pushButtonSaveVegetation.clicked.connect(self.saveshapefileVegetation)
        self.dlg.helpButton.clicked.connect(self.help)
        # self.dlg.progressBar.setValue(0)

        self.fileDialog = QFileDialog()
        self.OutputfileBuilding = None
        self.OutputfileVegetation = None

        # Polygon widget
        self.layerComboManagerPolygrid = QgsMapLayerComboBox(self.dlg.widgetPolyBuildings)
        self.layerComboManagerPolygrid.setCurrentIndex(-1)
        self.layerComboManagerPolygrid.setFilters(QgsMapLayerProxyModel.PolygonLayer)
        self.layerComboManagerPolygrid.setFixedWidth(175)

        # Building Raster widgets
        self.layerComboManagerDSMbuildground = QgsMapLayerComboBox(self.dlg.widgetDSMbuildground)
        self.layerComboManagerDSMbuildground.setFilters(QgsMapLayerProxyModel.RasterLayer)
        self.layerComboManagerDSMbuildground.setFixedWidth(175)
        self.layerComboManagerDSMbuildground.setCurrentIndex(-1)
        self.layerComboManagerDEM = QgsMapLayerComboBox(self.dlg.widgetDEM)
        self.layerComboManagerDEM.setFilters(QgsMapLayerProxyModel.RasterLayer)
        self.layerComboManagerDEM.setFixedWidth(175)
        self.layerComboManagerDEM.setCurrentIndex(-1)
        self.layerComboManagerDSMbuild = QgsMapLayerComboBox(self.dlg.widgetDSMbuild)
        self.layerComboManagerDSMbuild.setFilters(QgsMapLayerProxyModel.RasterLayer)
        self.layerComboManagerDSMbuild.setFixedWidth(175)
        self.layerComboManagerDSMbuild.setCurrentIndex(-1)

        # Vegetation Raster widgets
        self.layerComboManagerVEGDSM = QgsMapLayerComboBox(self.dlg.widget_CDSM)
        self.layerComboManagerVEGDSM.setFilters(QgsMapLayerProxyModel.RasterLayer)
        self.layerComboManagerVEGDSM.setFixedWidth(175)
        self.layerComboManagerVEGDSM.setCurrentIndex(-1)
        self.layerComboManagerVEGDSM2 = QgsMapLayerComboBox(self.dlg.widget_TDSM)
        self.layerComboManagerVEGDSM2.setFilters(QgsMapLayerProxyModel.RasterLayer)
        self.layerComboManagerVEGDSM2.setFixedWidth(175)
        self.layerComboManagerVEGDSM2.setCurrentIndex(-1)

        # Point vector widgets
        self.layerComboManagerPoint = QgsMapLayerComboBox(self.dlg.widgetPointVegetation)
        self.layerComboManagerPoint.setCurrentIndex(-1)
        self.layerComboManagerPoint.setFilters(QgsMapLayerProxyModel.PointLayer)
        self.layerComboManagerPoint.setFixedWidth(175)
        # self.layerComboManagerTotalHeightField = QgsFieldComboBox(self.dlg.widgetTotalHeight)
        # self.layerComboManagerTotalHeightField.setFilters(QgsFieldProxyModel.Numeric)
        # self.layerComboManagerPoint.layerChanged.connect(self.layerComboManagerTotalHeightField.setLayer)
        # self.layerComboManagerTrunkHeightField = QgsFieldComboBox(self.dlg.widgetTrunkHeight)
        # self.layerComboManagerTrunkHeightField.setFilters(QgsFieldProxyModel.Numeric)
        # self.layerComboManagerPoint.layerChanged.connect(self.layerComboManagerTrunkHeightField.setLayer)
        self.layerComboManagerDiameterField = QgsFieldComboBox(self.dlg.widgetDiameter)
        self.layerComboManagerDiameterField.setFilters(QgsFieldProxyModel.Numeric)
        self.layerComboManagerPoint.layerChanged.connect(self.layerComboManagerDiameterField.setLayer)

        if not (os.path.isdir(self.plugin_dir + '/tempdata')):
            os.mkdir(self.plugin_dir + '/tempdata')

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('URockPreprocessor', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/urock_preprocessor/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u''),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&URock Preprocessor'),
                action)
            self.iface.removeToolBarIcon(action)


    def run(self):
        """Run method that performs all the real work"""
        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        self.dlg.exec_()


    def start_progress(self):

        if self.dlg.checkBoxBuildingdata.isChecked():
            if self.OutputfileBuilding == None:
                QMessageBox.critical(None, "Error", "An output building polygon shapefile (.shp) must be specified")
                return

            poly = self.layerComboManagerPolygrid.currentLayer()
            if poly is None:
                QMessageBox.critical(self.dlg, "Error", "No valid Polygon layer is selected")
                return
            if not poly.geometryType() == 2:
                QMessageBox.critical(self.dlg, "Error", "No valid Polygon layer is selected")
                return

            if self.dlg.radioButtonMean.isChecked():
                statresult = 2
            if self.dlg.radioButtonMax.isChecked():
                statresult = 6
            if self.dlg.radioButtonMed.isChecked():
                statresult = 3

            # Building data
            if self.dlg.checkBoxOnlyBuilding.isChecked():  # Only building heights
                dsm_buildlayer = self.layerComboManagerDSMbuild.currentLayer()
                if dsm_buildlayer is None:
                    QMessageBox.critical(self.dlg, "Error", "No valid building DSM raster layer is selected")
                    return
                # load raster
                gdal.AllRegister()
                provider = dsm_buildlayer.dataProvider()
                filePathOld = str(provider.dataSourceUri())
                # dataSet = gdal.Open(filePathOld)
                # dsm_build = dataSet.ReadAsArray().astype(np.float)


            else:  # Both building ground heights
                dsmlayer = self.layerComboManagerDSMbuildground.currentLayer()
                if dsmlayer is None:
                    QMessageBox.critical(None, "Error", "No valid ground and building DSM raster layer is selected")
                    return

                # load rasters
                gdal.AllRegister()
                provider = dsmlayer.dataProvider()
                filePathOld = str(provider.dataSourceUri())
                dataSet = gdal.Open(filePathOld)
                dsm = dataSet.ReadAsArray().astype(np.float)
                
                demlayer = self.layerComboManagerDEM.currentLayer()
                if demlayer is None:
                    QMessageBox.critical(None, "Error", "No valid ground DEM raster layer is selected")
                    return

                gdal.AllRegister()
                provider = demlayer.dataProvider()
                filePathOld = str(provider.dataSourceUri())
                dataSet = gdal.Open(filePathOld)
                dem = dataSet.ReadAsArray().astype(np.float)

                dsm_build = dsm - dem
                dsm_build[(dsm_build < 2.)] = 0. # building higher than 2 meter

                self.saveraster(dataSet, self.plugin_dir + '/tempdata/builddsm.tif', dsm_build)

            # Populate height attribute in building vector data from rasterdata using zonal statistics
            pre = self.dlg.lineEditPrefix.text()
            self.populateBuildingHeights(self.plugin_dir + '/tempdata/builddsm.tif', poly.source(), statresult, self.dlg.textOutputBuildings.text(), pre)

        #Vegetation data
        if self.dlg.checkBoxVegdata.isChecked():
            if self.OutputfileVegetation == None:
                QMessageBox.critical(None, "Error", "An output vegetation polygon shapefile (.shp) must be specified")
                return
            if self.dlg.checkBoxPointData.isChecked():
                point = self.layerComboManagerPoint.currentLayer()
                if point is None:
                    QMessageBox.critical(self.dlg, "Error", "No valid Point layer is selected")
                    return
                dia_field = self.layerComboManagerDiameterField.currentField()

                self.vectorPointsToPolygon(point.source(), dia_field, self.dlg.textOutputVegetation.text())
            else:
                vegdsmlayer = self.layerComboManagerVEGDSM.currentLayer()

                if vegdsmlayer is None:
                    QMessageBox.critical(self.dlg, "Error", "No valid vegetation DSM selected")
                    return

                # get raster
                gdal.AllRegister()
                provider = vegdsmlayer.dataProvider()
                filePathCDSMtemp = str(provider.dataSourceUri())
                dataSet = gdal.Open(filePathCDSMtemp)
                vegdsm = dataSet.ReadAsArray().astype(np.float)
                if os.path.isfile(self.plugin_dir + '/tempdata/cdsm.tif'):
                    os.remove(self.plugin_dir + '/tempdata/cdsm.tif')
                self.saveraster(dataSet, self.plugin_dir + '/tempdata/cdsm.tif', vegdsm)
                filePathCDSM = self.plugin_dir + '/tempdata/cdsm.tif'

                if self.dlg.checkBoxTrunkExist.isChecked():
                    vegdsm2layer = self.layerComboManagerVEGDSM2.currentLayer()

                    if vegdsm2layer is None:
                        QMessageBox.critical(self.dlg, "Error", "No valid trunk zone DSM selected")
                        return

                    # get raster
                    gdal.AllRegister()
                    provider = vegdsm2layer.dataProvider()
                    filePathTDSM = str(provider.dataSourceUri())
                    # dataSet = gdal.Open(filePathTDSM)
                    # vegdsm2 = dataSet.ReadAsArray().astype(np.float)
                else:
                    trunkratio = self.dlg.spinBoxTrunkHeight.value() / 100.0
                    dataSet = gdal.Open(filePathCDSM)
                    vegdsm = dataSet.ReadAsArray().astype(np.float)
                    vegdsm2 = vegdsm * trunkratio
                    if os.path.isfile(self.plugin_dir + '/tempdata/tdsm.tif'):
                        os.remove(self.plugin_dir + '/tempdata/tdsm.tif')
                    self.saveraster(dataSet, self.plugin_dir + '/tempdata/tdsm.tif', vegdsm2)
                    filePathTDSM = self.plugin_dir + '/tempdata/tdsm.tif'

                self.rasterToPolygon(filePathCDSM, filePathTDSM, self.dlg.textOutputVegetation.text())


    def populateBuildingHeights(self, dsm_build, poly, statresult, OutputfileBuilding, pre):
        
        paramIn = { 'COLUMN_PREFIX' : pre + '_',
        'INPUT' : poly,
        'INPUT_RASTER' : dsm_build,
        'OUTPUT' : OutputfileBuilding,
        'RASTER_BAND' : 1,
        'STATISTICS' : [statresult] }

        print(paramIn)

        processing.run('native:zonalstatisticsfb', paramIn)

        QMessageBox.information(self.dlg, "URock Preprocessor", "URock building data generated")


    def vectorPointsToPolygon(self, inFile, dia_field, OutputfileVegetation):

        paramIn = { 'DISTANCE' : QgsProperty.fromExpression(str(dia_field)),
        'INPUT' : inFile,
        'OUTPUT' : OutputfileVegetation,
        'RINGS' : 1 }
         
        print(paramIn)

        processing.run('native:multiringconstantbuffer', paramIn)

        QMessageBox.information(self.dlg, "URock Preprocessor", "URock vegtation data generated")


    def rasterToPolygon(self, vegdsm, vegdsm2, OutputfileVegetation):

        paramIn = { 'FIELD_NAME' : 'tot_height',
        'INPUT_RASTER' : vegdsm,
        'OUTPUT' : self.plugin_dir + '/tempdata/temp.shp',
        'RASTER_BAND' : 1 }

        print(paramIn)

        processing.run('native:pixelstopolygons', paramIn)

        paramIn = { 'COLUMN_PREFIX' : 'trunk_',
        'INPUT' : self.plugin_dir + '/tempdata/temp.shp',
        'INPUT_RASTER' : vegdsm2,
        'OUTPUT' : OutputfileVegetation,
        'RASTER_BAND' : 1,
        'STATISTICS' : 2 }

        print(paramIn)

        processing.run('native:zonalstatisticsfb', paramIn)

        QMessageBox.information(self.dlg, "URock Preprocessor", "URock vegetation data generated")


    def saveshapefileBuilding(self):
        self.OutputfileBuilding = self.fileDialog.getSaveFileName(None, "Save File As:", None, "Shapefiles (*.shp)")
        if self.OutputfileBuilding[0][-4:] == '.shp':
            self.dlg.textOutputBuildings.setText(self.OutputfileBuilding[0])
        else:
            self.dlg.textOutputBuildings.setText(self.OutputfileBuilding[0] + '.shp')

    def saveshapefileVegetation(self):
        self.OutputfileVegetation = self.fileDialog.getSaveFileName(None, "Save File As:", None, "Shapefiles (*.shp)")
        if self.OutputfileVegetation[0][-4:] == '.shp':
            self.dlg.textOutputVegetation.setText(self.OutputfileVegetation[0])
        else:
            self.dlg.textOutputVegetation.setText(self.OutputfileVegetation[0] + '.shp')


    def help(self):
        url = 'https://umep-docs.readthedocs.io/en/latest/pre-processor/Urban%20Geometry%20Sky%20View%20Factor%20Calculator.html'
        # QDesktopServices.openUrl(QUrl(url))
        webbrowser.open_new_tab(url)

    def saveraster(self, gdal_data, filename, raster): # available from Utilities later on
        rows = gdal_data.RasterYSize
        cols = gdal_data.RasterXSize

        outDs = gdal.GetDriverByName("GTiff").Create(filename, cols, rows, int(1), GDT_Float32)
        outBand = outDs.GetRasterBand(1)

        # write the data
        outBand.WriteArray(raster, 0, 0)
        # flush data to disk, set the NoData value and calculate stats
        outBand.FlushCache()
        outBand.SetNoDataValue(0)

        # georeference the image and set the projection
        outDs.SetGeoTransform(gdal_data.GetGeoTransform())
        outDs.SetProjection(gdal_data.GetProjection())
        outDS = None
